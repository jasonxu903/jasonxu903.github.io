<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[说说这几天]]></title>
    <url>%2F2018%2F09%2F16%2F%E8%AF%B4%E8%AF%B4%E8%BF%99%E5%87%A0%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[离家一个星期了。 从兰州到扬州，又到宝应，背负了太多压力。 家里怎么样了？工作能适应吗？我会一直害怕下去吗？ 我不知道。 买了一辆山地车，我的本意是锻炼身体，但是要说这几天骑行的感受，就是真TM累呀，我能坚持到什么时候呢？无论如何坚持到明年过完年吧，一定要咬住牙。 买了大F的minila，希望给自己更多写代码的助力，我希望用这把键盘学会vim，就像学会双拼一样，多用，就学得会。 真不知道这是时隔多久又写的日记，这算日记吗？就算吧，不然我也不知道为什么写这个东西了。 希望一切顺利。]]></content>
      <categories>
        <category>words</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[box-shadow 那点事]]></title>
    <url>%2F2018%2F09%2F03%2Fbox-shadow-%E9%82%A3%E7%82%B9%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[box-shadow 是个啥呀？咋用呀？ 来吧，让小白带你走上歧途！ 现在的网页越来越炫酷了，特别是 CSS3 时代来临之后，仅仅只用 CSS 代码就能写出非常带感的页面。在 CSS3 的一众新特性中，box-shadow 是极为重要的属性，它能为你页面内的某些元素增加阴影效果，使之产生立体感，绝对是页面美化的重要手段之一。 下面，我们就来简单探讨一下 box-shadow 属性。 是什么首先要知道 box-shadow 是什么。 在 MDN 上，它的定义是这样的： box-shadow 以由逗号分隔的列表来描述一个或多个阴影效果。该属性让你可以对几乎所有元素的边框产生阴影。如果元素同时设置了 border-radius ，阴影也会有圆角效果。 简单来说，就是给你的页面元素加一个阴影效果，让它成为区别与其他元素的“妖艳贱货”。 怎么用语法先来看看 box-shadow 的语法： 1box-shadow: offset-x offset-y blur-radius spread-radius color inset; 下表是每个值的具体说明： 值 说明 offset-x 水平阴影的位置，允许负值，必需。 offset-y 垂直阴影的位置，允许负值，必需。 blur-radius 模糊距离，可选。 spread-radius 阴影大小，可选。 color 阴影颜色，可选。 inset 从外层的阴影（开始时）改变阴影内侧阴影，可选。 使用了解过语法和每个值后，就来动手试试吧。 我用下面的代码构建了一个基本的方块，用于后面的所有实验，你也可以自己构建一个类似的。 12345678910&lt;style&gt; div &#123; margin: 50px auto; width: 200px; height: 100px; border: 1px solid; &#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 基础实验在 css 中加入下面这行代码： 1box-shadow: 20px 20px grey; /* offset-x offset-y color */ 于是，方块变成了下面这样 可以看到，在方块的 x 方向和 y 方向上均出现了灰色的区域，而这个区域似乎与方块的位置有密切的关系。这个区域，就是通过上面的代码得到的方块的阴影。 分析这个现象可以看出： 当 offset-x 值为 20px 时，阴影向右偏移了 20px 的距离； 当 offset-y 值为 20px 时，阴影向下偏移了 20px 的距离； 阴影的颜色就是 color 的值。 由此我们可以得出一个初步的结论，那就是方块的阴影是根据方块本身的位置，按照 offset-x 和 offset-y 的值进行偏移的。 负值实验上一个实验中，我们用的都是正值，但 offset-x 和 offset-y 都是允许负值的，那么，如果使用负值的话，会是什么结果呢？ 把代码换成下面的： 1box-shadow: -20px -20px grey; /* offset-x offset-y color */ 方块产生了如下的变化 可以看到，阴影的方向与之前的实验结果完全相反，原本出现在右下方的阴影现在出现在左上方。 由此，我们得到了这样一个结论： 阴影的位置是根据方块的位置偏移的。 根据 offset-x 的值不同，偏移的方向不同：当该值为正时，在 x 轴上向右偏移；当该值为负时，在 x 轴上向左偏移。 同理可得 offset-y 值的变化规律：当值为正时，在 y 轴上向下偏移，当值为负时，在 y 轴上向上偏移。 模糊实验前面的语法说明中，有一个名为 blur-radius 的值，它有什么用呢？动手试一下： 1box-shadow: 20px 20px 20px grey; /* offset-x offset-y blur-radius color */ 增加了新的值后，产生了如下变化： 我们发现，阴影变得模糊了。那么，模糊的程度是不是和 blur-radius 正相关呢？改动代码如下： 1box-shadow: 20px 20px 50px grey; /* offset-x offset-y blur-radius color */ 于是，我们得到了新的结果，如下图： 没错了，blur-radius 的值越大，阴影越模糊。 阴影大小控制实验在语法说明中，还有一个 spread-radius 值，它的解释是阴影大小。它所说的阴影大小和我们直观理解的阴影大小是不是一回事呢？动手试一下。 为了展现实验的最直观结果，我们去掉阴影模糊，同时 box-shadow 的值必需有一个书写顺序，所以我们把 blur-radius 设为 0，代码如下： 1box-shadow: 20px 20px 0 20px grey; /* offset-x offset-y blur-radius spread-radius color */ 改变代码后，我们得到了下面的结果： 根据结果，我们观察到两个现象： 阴影与方块在上端和左端实现了对齐，也就是说在横轴上向左延伸了 20px，在纵轴上向上延伸了 20px； 与基础实验的结果相比，明显看出阴影变宽了，肉眼可见的是宽度增加了一倍（实测结果也是这样），也就是说，阴影在横轴上向右延伸了 20px，在纵轴上向下延伸了 20px。 综合以上两个现象，可以得到一个结论，就是 spread-radius 会使阴影在各个方向上得到延伸，并且只要该值足够大，阴影就会包围方块（比如将本实验的值改成 30px，方块就会被阴影包围）。有兴趣的读者可以自行实验。 内侧阴影实验语法说明中还有一个 inset 属性，直观上我并不理解 inset 能产生的效果，所以直接进入实验环节看看这个属性能带来什么改变。 更改基础实验的代码如下： 1box-shadow: 20px 20px grey inset; /* offset-x offset-y color inset */ 代码更改后得到如下结果： 对比基础实验的结果，发现三个有趣的现象： 基础实验中的阴影在方块外面，增加 inset 值后阴影跑到了方块里面； 基础实验中的阴影在方块的右下方，增加 inset 值后阴影跑到了方块的左上方； 基础实验中的阴影在横轴和纵轴上与方块均存在落差，增加 inset 值后阴影在方块里面没有显现出差值，方块的长宽是多少，阴影的长宽就是多少。 这就是 inset 值所带来的影响。该值可以对除了颜色外的其它所有值产生影响，特别是当阴影包围方块时，inset 值会产生很有趣的结果，留给读者自己尝试吧。 多条列表实验根据 MDN 的定义我们知道，box-shadow 可以接受由逗号分开的多条列表，那么多条列表会产生什么效果呢？让我们来试试。 将基础实验的代码更改如下： 1box-shadow: 20px 20px grey, -20px -20px grey; 得到的结果如下图 由实验我们可知，多条列表就是给一个元素增加多个阴影。 至于它能产生怎样的效果，就有待读者自己发掘了。 颜色color 值和其它 CSS 属性的 color 值类似，可以使用关键字、十六位进制、rgb、rgba 等多种方式表达，不再具体阐述。 实验后总结通过上面的5个小实验，我想读者对于 box-shadow 各个值的意义一定有了更深层次的理解。让我们重新对值的说明做一个简单的易于理解的解读： 值 说明 offset-x 控制阴影在横轴上的偏移，正值时向右偏移，负值时向左偏移。 offset-y 控制阴影在纵轴上的偏移，正值时向下偏移，负值时向上偏移。 blur-radius 控制阴影的模糊程度，值越大越模糊，不允许负值。 spread-radius 控制阴影在各个方向的延伸，值越大阴影越大，不允许负值。 color 控制阴影颜色。 inset 该属性会使阴影在除了颜色外的其它方面呈现完全相反的结果。 限于文字水平不足，希望读者能够理解我的意思，并作出更高层次的总结归纳。 一个小彩蛋怎样做一个好看的四面模糊阴影效果呢？ 1box-shadow: 0 0 5px grey; /* offset-x offset-y blur-radius color */ 以上！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 知识总结]]></title>
    <url>%2F2018%2F09%2F02%2FCSS-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本文将以问答形式对 CSS 知识做一个总结。 CSS 基础知识CSS 的全称是什么？Cascading Style Sheets. CSS 有几种引入方式？ 内联样式 1&lt;h1 style="color:red;"&gt;这是内联样式&lt;/h1&gt; 内部样式 1234567&lt;style&gt; h1 &#123; color:red; &#125;&lt;/style&gt;&lt;h1&gt;这是内部样式&lt;/h1&gt; 外联样式 12345678/* 用 link 标签引入样式表 */&lt;link rel="stylesheet" type="text/css" href="index.css"&gt;/* 用 @import 引入样式表 */&lt;style&gt; @import url("index.css") @import "index.css"&lt;/style&gt; &lt;link&gt; 标签和 @import 有什么区别？ link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 link支持使用Javascript控制DOM去改变样式；而@import不支持。 什么是相对路径和绝对路径？ 相对路径是相对于文件本身的 URL。 绝对路径是相对于根节点的 URL。 html 中引入资源的相对路径与网页的 URL 有关，而 css 中则与 css 资源本身 URL 有关。但使用绝对路径时，不管是在 html 中，还是 css 中，都只与网页 URL 的根路径有关。 CSS 选择器class 和 id 的使用场景？ class用于主区块里面的详细内容，同一个class可以重复出现，一个标签可以有几个不同的class。 id多使用于主要块级元素，id一个页面中只能出现一次，有些独一无二元素也可用id。 css 选择器常见的有几种？ 基础选择器 组合选择器 属性选择器 伪类选择器 伪元素选择器 选择器的优先级是怎样的？对于复杂场景如何计算优先级？选择器的优先级从高到低分别是： 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式 作为style属性写在元素标签上的内联样式 id选择器 类选择器 伪类选择器 属性选择器 标签选择器 通配符选择器 浏览器自定义 复杂场景优先级计算规则是： 行内样式计数1000； id选择器计数100； 类、属性、伪类选择器计数10； 标签、伪元素选择器计数1； 通过以上计数计算选择前的优先级结果，数字越大优先级越高。 a:link a:hover a:active a:visited 的顺序是怎样的？为什么？a:link -&gt; a:visited -&gt; a:hover -&gt; a:active 鼠标经过的“未访问链接”同时拥有 a:link、a:hover、a:active 三种属性，后面的属性会覆盖前面的属性定义，所以 a:link 必须放在 a:hover 的前面，a:hover必须放在a:active` 的前面。 鼠标经过的“已访问链接”同时拥有 a:visited、a:hover、a:link 三种属性，后面的属性会覆盖前面的属性定义，此时 a:visted 和 a:link 必须放在 a:hover的前面。 列出你知道的伪类选择器 E:first-child: 匹配作为长子（第一个子女）的元素E E:link: 匹配所有未被点击的链接 E:visited: 匹配所有已被点击的链接 E:active: 匹配鼠标已经其上按下、还没有释放的E元素 E:hover: 匹配鼠标悬停其上的E元素 E:focus: 匹配获得当前焦点的E元素 E:lang(c): 匹配lang属性等于c的E元素 E:enabled: 匹配表单中可用的元素 E:disabled: 匹配表单中禁用的元素 E:checked: 匹配表单中被选中的radio或checkbox元素 E::selection: 匹配用户当前选中的元素 E:root: 匹配文档的根元素，对于HTML文档，就是HTML元素 E:nth-child(n): 匹配其父元素的第n个子元素，第一个编号为1 E:nth-last-child(n): 匹配其父元素的倒数第n个子元素，第一个编号为1 E:nth-of-type(n): 与:nth-child()作用类似，但是仅匹配使用同种标签的元素 E:nth-last-of-type(n): 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素 E:last-child: 匹配父元素的最后一个子元素，等同于:nth-last-child(1) E:first-of-type: 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1) E:last-of-type: 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1) E:only-child: 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1) E:only-of-type: 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1) E:empty: 匹配一个不包含任何子元素的元素，文本节点也被看作子元素 E:not(selector): 匹配不符合当前选择器的任何元素 div:first-child div:first-of-type div :first-child div :first-of-type 的作用和区别（注意空格的作用）div:first-child 和 div :first-child 的对比div:first-child 选中的是页面中所有 &lt;div&gt; 中的第一个 &lt;div&gt; 元素。而 div :first-child 选中的是所有 &lt;div&gt; 内的第一个子元素，无论这个子元素是什么。演示 div:first-of-type 和 div :first-of-type 的对比div:first-of-type 选中的是页面中所有 &lt;div&gt; 中的第一个 &lt;div&gt; 元素。而 div :first-of-type 选中的是所有 &lt;div&gt; 内的所有子元素类型的第一个子元素，比如这个 &lt;div&gt; 里有5个 &lt;p&gt; 标签和15个 &lt;span&gt; 标签，那么就选中 &lt;p&gt; 标签中的第一个和 &lt;span&gt; 标签中的第一个。演示 CSS 常见属性块级元素和行内元素分别有哪些？列出4条以上的特性区别块级元素 div h1 h2 h3 h4 h5 h6 p hrform ul dl ol pre tableli dd dt tr td th 行内元素 em strong span a br imgbutton iput label select textareacode script 特性区别： 块级(block-level); 行内(内联、inline-level) 块级可以包含块级和行内，行内只能包含文本和行内 块级占据一整行空间，行内占据自身宽度空间 宽高设置、内外边距的差异 什么是 CSS 继承？哪些属性能继承，哪些不能继承？CSS继承指父元素的CSS属性被其子孙元素继承。 不可继承的： display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。 所有元素可继承： visibility和cursor。 内联元素可继承： letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。 终端块状元素可继承： text-indent和text-align。 列表元素可继承： list-style、list-style-type、list-style-position、list-style-image。 表格元素可继承： border-collapse。 如何让块级元素水平居中？如何让行内元素水平居中？块级元素水平居中： 设一个固定的宽度 margin: 0 auto; 行内元素水平居中：对其父元素设置 text-align: center; 即可 px、em、rem 有什么区别？ px 是像素单位，也是一个固定值单位。 em 是倍数单位，根据其父元素的大小计算其大小，是一个不固定值的单位。 rem 是倍数单位，根据 HTML 文档的根元素 &lt;html&gt; 的大小计算其大小，是一个不固定值的单位。 IE 盒模型和 W3C 盒模型有什么区别？IE盒模型和W3C盒模型的区别是宽和高的组成： IE 盒模型的宽和高由 border 、padding 、content 三个元素相加而成； W3C 盒模型的宽和高就是 content 的宽和高，不受 border 和 padding 影响。 line-height: 2 和 line-height: 200% 有什么区别？ line-height: 2 是以元素本身的字体大小计算行高值，随着该元素字体大小的变化而变化，自适应性更好； line-height: 200% 是以父元素的字体大小计算行高值，不会跟随本元素变化，当本元素的字体过大时，由于行高不变文字会挤在一起，自适应性差。 inline-block 有什么特性？如何去除缝隙？高度不一样的 inline-block 元素如何顶端对齐?inline-block 既呈现 inline 特性(不占据一整行，宽度由内容宽度决定)，又呈现 block 特性 (可设置宽高，内外边距)。 去除缝隙的方法： 在两个 inline-block 间不加空白或折行； 如果有空白或折行，将父元素的 font-size 设为 0，再对 inline-block 元素分别设置 font-size 值。 顶端对齐：给父元素设置 vertical-align: top 让一个元素“看不见”有几种方式？有什么区别？ opacity: 0;: 透明度为0，整体透明，但仍然占用位置； visibility: hidden;: 和 opacity:0 类似； display:none;: 消失，不占用位置； background-color: rgba(0，0，0，0); 背景色透明； 浮动定位BFC边距合并浮动元素有什么特征？对父容器、其他浮动元素、普通元素、文字分别有什么影响?浮动元素的特征 浮动元素会脱离正常文档流，文档流中的其他正常块级元素将不再感知浮动元素的存在； 浮动元素会向左或向右移动，直到碰到父元素的边框或其他的浮动元素为止。 对父容器的影响浮动元素会引起父容器的高度塌陷问题。 对其他浮动元素的影响当有多个元素浮动时，浮动元素会按浮动方向的顺序依次排列，当父容器的宽度不够容纳所有的浮动元素时，超出父容器宽度的浮动元素将被挤下去，如果某个浮动元素的高度超出其他浮动元素，被挤下去的浮动元素会被这个更高的浮动元素卡住。 对普通元素的影响由于浮动元素会脱离正常的文档流，其他的普通元素将不再感知浮动元素的存在，原本排列在浮动元素后面的元素将占据浮动元素所占的位置，浮动元素也将覆盖在普通元素的上方。 对文字的影响与普通元素不同，文字仍然能够感知到浮动元素的存在，所以文字将围绕浮动元素排列。 清除浮动指什么? 如何清除浮动?清除浮动指通过 clear 属性解决浮动元素的父容器的高度塌陷问题。 清除浮动的方法： 在父容器最后添加一个空的，对其使用clear属性，清除浮动； 创建BFC，由于BFC包含浮动的特性，可以达到清除浮动的效果。 两种方法各有优缺点，其中创建BFC又有很多种方法，每一种方法也有各自的优缺点，所以在清除浮动时一定要谨慎选择最适合的一种。 有几种定位方式，分别是如何实现定位的，参考点是什么，使用场景是什么？定位方式分为相对定位、绝对定位和固定定位。 relative相对定位，是相对于自身在文档流中的位置，根据top/right/bottom/left值进行偏移，以实现定位，参考点是元素自身，使用场景是该元素需要保留在文档流中的位置时。 absolute绝对定位，绝对定位元素会脱离文档流，所以其参考点是离它最近的position值不为static的上级元素，如果找不到，最后将参考html根元素，然后根据其top/right/bottom/left值进行偏移实现定位，使用场景是需要根据其父元素确定位置时。 fixed固定定位，是以浏览器窗口为参考点，通过top/right/bottom/left值偏移确定位置的定位方式，使用场景是需要某个元素在浏览器窗口内固定位置不动时。 z-index 有什么作用? 如何使用?z-index属性可以控制元素的叠放顺序，z-index值越高，元素的位置越靠近使用者。 position:relative 和负 margin 都可以使元素位置发生偏移?二者有什么区别 relative 的偏移只是视觉效果上的偏移，元素本身的位置并没有发生变化，对其他元素的位置也不会产生影响。 负 margin 会使元素的位置发生变化，对其他元素的位置也会产生影响。 BFC 是什么？如何生成 BFC？BFC 有什么作用？举例说明BFC全称 Block formatting contexts ，即块级格式化上下文。 生成BFC可以通过以下几种方式： 根元素； float属性不为none； display属性为inline-block、table-cell、table-caption之一； overflow属性不为visible position属性为relative、absolute、fixed之一。 BFC的作用： BFC会阻止垂直外边距（margin-top、margin-bottom）折叠； BFC不会重叠浮动元素； BFC可以包含浮动。 在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？当两个元素的垂直外边距相遇时，会合并成一个外边距。 合并后的外边距的大小取合并前两个元素的垂直外边距较大的一个。 根据BFC阻止垂直外边距折叠的特性，将相邻元素放在不同的BFC中，即可防止相邻元素外边距合并。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>总结QA</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 知识总结]]></title>
    <url>%2F2018%2F09%2F02%2FHTML-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本文将以问答形式对 HTML 知识做一个总结。 HTML 基础知识HTML, XML, XHTML 有什么区别？ HTML: 超文本标记语言，是语法较为松散、不严格的 web 语言。 XML: 可扩展标记语言，主要用于存储数据和结构。 XHTML: 可扩展超文本标记语言，基于 XML，语法类似于 HTML，但更加严格。 怎样理解 HTML 语义化？HTML 语义化，是指选择合适的标签、使用合理的代码结构，便于开发者阅读，同时让浏览器的爬虫和机器更好的解析。 怎样理解内容与样式分离原则？ 写 HTML 时将重点放在结构和语义化上，先不管样式，在保证 HTML 能体现出页面结构和内容的基础上，再用 CSS 调整样式； 写 JS 时，尽量不要直接操作样式，应该通过给元素增删 class 属性值，配合 CSS 来改变元素的样式； HTML 内不允许出现属性样式，尽量不要写行内样式。 &lt;meta&gt; 标签有哪些常见的属性？ charset: 编码格式，告诉浏览器页面的编码方式，避免出现解析错误。 name=&quot;viewport&quot;: 使页面更适用于移动端的展示。 name=&quot;keywords&quot;: 向搜索引擎提供页面的关键字信息。 name=&quot;description: 向搜索引擎提供页面的描述性信息。 文档声明的作用是什么？向浏览器声明该页面是基于哪一版 HTML 规范编写的，以便浏览器能正确的解析。 严格模式和混杂模式指什么？ 严格模式也成为标准模式，在严格模式下，浏览器会严格按照 HTML 和 CSS 标准来解析、渲染文档。 混杂模式的由来是一个历史问题。在互联网早期，网页一般写成两个版本：一个写给网景公司的 Navigator 浏览器，一个写给微软公司的 IE 浏览器。当W3C制定了 Web 标准后，这两个浏览器不能马上开始按标准来解析渲染页面，因为这样会破坏当时大部分页面的显示效果。所以各浏览器就引入了混杂模式，在该模式下，浏览器会模拟 Navigator 4 和 IE 5 的非标准行为来解析渲染页面，这样做就是为了兼容在W3C标准出现之前就存在的那些“不标准”的页面。 建议使用严格模式编写你的页面，保证浏览器能正确地解析它。 &lt;!DOCTYPE html&gt; 的作用是什么？作用是让浏览器按照最新的 HTML5 标准，以严格模式来解析和渲染页面。如果缺少这个声明，浏览器就会进入混杂模式，而这是我们必须避免的。 浏览器乱码的原因是什么？怎样解决？导致浏览器出现乱码有两种情况： 没有声明页面的编码格式，浏览器在不知道其编码格式的情况下，会以随机的编码格式解析页面，通常都不能与页面的正确编码格式匹配，从而导致乱码； 声明的编码格式与用户浏览器选择的编码格式不同，比如页面的编码格式是 utf-8，而用户为浏览器选择的编码格式是 GBK，就会导致出现乱码。 只要解决页面编码格式与浏览器编码格式的匹配问题，乱码问题也就解决了。 常见浏览器有哪些？分别是什么内核？ IE浏览器，Trident内核。 Chrome浏览器，Webkit内核。 Firefox浏览器，Gecko内核。 双内核浏览器，通常拥有Trident和Webkit两个内核，如360、猎豹等 列出常见标签，并简单说明这些标签的应用场景。 &lt;html&gt; 标签，是 HTML 文档的根标签，其他所有标签都必须包含在 &lt;html&gt; 标签内。 &lt;head&gt; 标签，是HTML文档的头部标签，包含了与 HTML 文档相关的非页面展示内容的信息，文档中只能有一个 &lt;head&gt; 标签。 &lt;body&gt; 标签，是 HTML 文档的内容主体标签，包含了所有页面展示内容，文档中只能有一个 &lt;body&gt; 标签。 &lt;div&gt; 标签，是块标签，用于 HTML 文档的内容分区，使其结构更清晰。 标题标签，分别是 &lt;h1&gt; &lt;h2&gt; &lt;h3&gt; &lt;h4&gt; &lt;h5&gt; &lt;h6&gt;，数字越小标题越大越重要。 &lt;p&gt; 标签，是段落标签，用于标示文档的文字内容。 &lt;a&gt; 标签，是超链接标签，用于标示文档内的超链接。 &lt;img&gt; 标签，是图片标签，用于在文档内插入一张图片，&lt;img&gt; 标签是自闭合标签。 &lt;table&gt; 标签，是表格标签，用于标示文档内的表格。 &lt;ul&gt; &lt;ol&gt; 标签，分别是无序列表标签和有序列表标签，用于标示文档内的列表内容，&lt;li&gt; 标签是它们的列表项标签。 &lt;strong&gt; &lt;em&gt; &lt;span&gt; 标签，都是行内强调标签，&lt;strong&gt; 语义最强，&lt;span&gt; 语义最弱。需要注意的是，不要为了改变样式而使用 &lt;strong&gt; 和 &lt;em&gt;，这样是不符合语义化要求的。 FORM 表单form 表单有什么作用？form 表单的主要作用是采集和传输用户信息。 有哪些常用的 &lt;input&gt; 标签？分别有什么作用？ text 标签，用于输入单行文本； password 标签，用于输入密码； checkbox 标签，用于多选项分组； radio 标签，用于单选项分组； value 标签，向后台传输单选或多选结果的必要属性； file 标签，用于上传文件功能，可以用 accept 属性限制上传文件的类型； hidden 标签，用于定义隐藏的输入字段，暂存数据或信息安全等； button 标签，用于定义可点击按钮，多用于通过JavaScript启动脚本； submit 标签，用于定义提交按钮，将表单数据发送到服务器； reset 标签，用于定义重置按钮，将表单数据清空重置。 post 和 get 方式的区别是什么？ 传输方式不同：get会将表单的key值和value值拼接组成URL发送给服务器，post不会改变URL； 安全性不同：get发送的URL使用明文方式组成，存在明显的安全隐患，post不会出现这个问题； 传输数据大小不同：get发送数据时会受到URL字符数的限制，post不受这个限制； 作用对象不同：get通常用于向服务器索取数据，post通常用于向服务器发送数据。 在 &lt;input&gt; 标签里，name 属性的作用是什么？name 属性规定了 &lt;input&gt; 元素的名称，用于对表单数据标识，只有标识过的数据才能正确的向服务器传递值。 radio 如何分组？radio 标签通过 name 属性分组，name 值相同的为一组，同组 radio 只能单选一个 value 值传送数据。 placeholder 属性有什么作用？placeholder 属性用于在输入框内展示一个提示信息，这个信息不会跟随用户输入的表单数据一起传送给服务器。 type=&quot;hidden&quot; 隐藏域有什么作用？服务器可以先向 hidden 传送一个随机值，当用户向服务器传送数据时，服务器再验证 hidden 是否被更改，以此判定用户传送的数据是否被篡改，以确保数据信息的安全，其作用类似于隐形的验证码。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>总结QA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 新建打开自动化]]></title>
    <url>%2F2018%2F09%2F01%2Fhexo-%E6%96%B0%E5%BB%BA%E6%89%93%E5%BC%80%E8%87%AA%E5%8A%A8%E5%8C%96%2F</url>
    <content type="text"><![CDATA[本篇用一个脚本实现新建文章时自动打开文本编辑器，如果你希望写博客的时候更智能一点，那么就往下看吧～ Let’s go! 如何实现自动化我们知道，新建一遍博客的命令是 hexo n &lt;title&gt;，在正常情况下，新建完成后是要自己手动打开对应文档去编辑内容的。有些喜欢按某种规则分类整理文件夹的同学可能会面临本地博客目录埋得太深的情境，这时候手动用编辑器打开就显得有些繁琐。 有没有什么办法能让编辑器在新建完成后自动打开呢？ 当然是有的，只需要编写一小段脚本即可满足你的愿望。 在你的博客根目录下，进行如下操作： 新建 scripts 文件夹； 在 scripts 文件夹内新建 auto.js 文件并编辑； 复制下面的代码进去，保存退出。 Windows 平台12345678910// 以下代码针对 Windows 平台var spawn = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; exec('start "markdown编辑器绝对路径.exe" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; exec('start "markdown编辑器绝对路径.exe" ' + data.path);&#125;); Mac 平台12345678910// 以下代码针对 Mac 平台var exec = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + data.path);&#125;); Linux 平台Linux 平台下没有找到相关代码，只有一位博主根据 Mac 的代码自己写了一段，据说可以在所有平台通用，我没有试过，请读者自行尝试吧。 12345var exec = require('child_process').exec;hexo.on('new', function(data)&#123; exec('atom' +' '+ data.path);&#125;); 博主发现其实只要是能在命令行下直接以命令打开的编辑器都可以这样子用，比如sublime &amp; vim &amp; atom,也就是说最后这个应该是适用于所有平台(windows上测试过了没有问题)。 个人经验我是在 Mac 平台上搭建的博客，Mac 的编辑器绝对路径是 /Applications ，假设你用的编辑器是 atom，那么你应该在绝对路径处填写的就是 /Applications/atom.app。Windows 平台下的绝对路径请读者自行尝试。]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态博客搭建指北（二）]]></title>
    <url>%2F2018%2F08%2F31%2F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8C%97%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[静态博客搭建第二弹上线啦～ 本篇集中于 NexT 主题配置问题，将博客美化成你喜欢的样子（大概）～ Let’s go! 添加「标签」页面以下内容参考 「NexT」主题配置 在终端窗口下，定位到 Hexo 站点目录下输入以下命令： 1$ hexo new page tags 编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下： 1234title: 标签date: 2014-12-22 12:39:04type: "tags"--- 在菜单中添加链接。编辑主题配置文件， 添加 tags 到 menu 中，如下: 1234menu: home: / archives: /archives tags: /tags 同样的原理，分类(categories)、关于(about)等页面也可以自行添加了。 给文章模版增加分类选项当我们通过 hexo n &quot;name&quot; 命令来新建一篇文章时，默认格式是这样的12345---title: namedate: yyyy-mm-dd xx:xx:xxtags:--- 可编辑的选项有标题、时间、标签，但是没有分类选项，如果每次都手动添加，难免感到麻烦。所以让我来给文章模版加入 categories: 项： 找到站点根目录下的 scaffolds/post.md 文件 打开该文件，在 tags: 项上面添加 categories: 并保存 再次执行 hexo n &quot;name&quot; 命令，新建的文件里就有 categories: 项了 增加 Read more 按钮默认情况下，首页的博文会显示全文，不仅阅读不方便，对一些人来说也不美观（没错就是我）。 修改 NexT 的配置文件限制博文在首页显示的长度可以解决这个问题，但会造成代码块显示混乱等一些问题。 最好的解决办法就是在每一篇博文里增加一行 &lt;!--more--&gt; 分隔符，hexo 会自动识别这行分隔符，在首页只显示分隔符上面的内容，分隔符下面的内容必须进入文章才能看到。但是手动给每一篇文章添加这个分隔符实在过于繁琐，一不小心就会忘记，所以我们来修改文章模版，将这条分隔符添加进去。 前面我们已经通过增加分类选项修改过一次文章模版文件了，再次打开这个文件，增加代码使之变成下面的格式 12345678---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:---&lt;!--more--&gt; 你可以在 &lt;!--more--&gt; 上面的位置写一些类似于文章摘要的东西，把文章主体放在下面的位置，对于不喜欢首页显示全部内容的同学，现在你的首页会焕然一新。 设置分类列表有时我们给文章设置的分类会包含中文，比如1categories: 编程 这样推送后，分类列表里就会出现编程这个选项，但是有点瑕疵的是访问路径也会包含中文1*/categories/编程 如果不希望这种情况出现，可以通过设置站点配置文件实现123456# Category &amp; Tagdefault_category: uncategorizedcategory_map: 编程: programming 生活: life 其他: other 修改主题样式NexT 主题包含有四种样式，如果你不喜欢默认的样式，可以修改配置文件换一个你喜欢的样式。 打开主题文件夹下的配置文件 _config.yml 找到下面的字段： 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini Muse 就是 NexT 默认的样式，删除你想要切换的样式前面的注释符号 #，再将默认样式注释掉，保存更改并重新生成即可完成修改，打开本地服务器看看新的样式，满意的话就可以部署上线了。 另外，配置文件中有这样一个字段： 1234sidebar: # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: left #position: right 这一项配置对应修改的是边栏所在的位置，但需要注意的是，只有第三个样式 Pisces 支持这项修改，所以如果你喜欢 Pisces 的风格，不妨也试试这个选项吧。 第二弹到这里就结束了，内容不多，但相对第一弹更偏向细节，毕竟粗枝大叶的搭建工作在第一弹已经完成了，剩下的都是细节～ 以上！]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态博客搭建指北（一）]]></title>
    <url>%2F2018%2F08%2F31%2F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8C%97%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[作为一只小白，从零开始自己搭建博客站点，可能要踩很多坑。 写这篇文章，最重要的目的就是记录过程，万一日后玩脱了也不致于从搜索开始全部重来一遍。 Let’s go! 部署前的准备博客放在哪里首先要决定博客托管的地方。GitHub Pages 是一个不错的选择，毕竟 GitHub 出品，安全、稳定、高效，拥有如此多的优点并且免费，对我来说就是首选了。 使用什么框架Google 一下适用于 GitHub Pages 的静态博客框架，出现频率最高的是 Hexo 和 Jeckll ，GitHub 似乎对 Jeckll 有某种程度上对原生支持，但 Hexo 是基于 JavaScript 和 Nodejs 的应用，对一个前端学习者而言，凡是能和所学搭边的都有无比对吸引力，于是毫不犹豫选择 Hexo 。 GitHub 上需要做的准备在你的 GitHub 上新建一个仓库，注意仓库名的规则，否则不能用作 GitHub Pages 。 username.github.io 这里的 “uesrname” 就是你创建仓库时前面的 “Owner” 下的名字。 之后勾选下面的 “Initialize this repository with a README”，点击创建仓库即可。 部署过程Hexo文档上有详实的部署及配置说明，在此只列出部分基本操作，更多具体选项和配置请阅读文档相关条目（其实就是不会 →_→ ）。 安装 Hexo安装 Hexo 前，首先检查计算机中是否已安装下列应用程序： Node.js Git 上述应用程序安装完毕后，就可以安装 Hexo 了。 1$ npm install -g hexo-cli 在本地建站安装完后执行下列命令， Hexo 会在指定文件夹内新建所需的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 执行命令后在指定文件夹内会出现以下文件结构。 1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 再执行以下命令，安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 配置“_config.yml” 文件保存了大部分网站配置信息，部分配置说明如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #博客的基本信息title: Blog Title #博客标题subtitle: #博客副标题description: #博客描述，部分主题会用来生成简介author: Your Name #博客作者language: zh-Hans #语言timezone: #时区，默认与你的计算机相同# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com #你自己的域名root: / #根目录位置，如果只是github pages的子目录需要更改permalink: :year/:month/:day/:title/permalink_defaults:# Directory #文件结构 默认即可source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing #编辑博文的选项new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: #代码高亮 enable: true #是否启用 line_number: true #是否显示行号 auto_detect: true tab_replace:# Category &amp; Tag #分类与标签default_category: uncategorizedcategory_map:tag_map:# Date / Time format #日期显示格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination #分页器## Set per_page to 0 to disable paginationper_page: 3pagination_dir: page# Extensions #拓展## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/## 主题安装参照下文所述theme: next #主题更换# Deployment #部署参数## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:username/username.github.io.git #你的GitHub仓库地址 branch: masterindex_generator: per_page: 3 ##首頁默认10篇文章标题 如果值为0不分页archive_generator: per_page: 10 ##归档页面默认10篇文章标题 yearly: true ##生成年视图 monthly: true ##生成月视图tag_generator: per_page: 10 ##标签分类页面默认10篇文章category_generator: per_page: 10 ###分类页面默认10篇文章 常用指令 hexo n &lt;title&gt;: 新建一篇文章 hexo g: 生成静态文件 hexo d: 部署上线 hexo s: 启动本地服务器 hexo clean: 清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 美化及扩展换一个主题如果不喜欢 Hexo 的默认主题，可以在主题商店中挑选你好看的主题安装，下面以使用人数较多的 NexT 主题为例讲解如何安装一款主题。 执行下列命令，安装主题。 12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next 执行下列命令，更新主题 12$ cd themes/next$ git pull 更新 Hexo 配置文件 “_config.yml” 1theme: next 至此，主题更换完毕 装一个插件初始状态下的 NexT 主题是没有搜索功能的，所以我们需要为其安装搜索服务。 我选取 Local Search 做为我的博客的搜索服务。 安装 hexo-generator-searchdb ，在站点的根目录下执行以下命令 1$ npm install hexo-generator-searchdb --save 编辑站点配置文件 _config.yml ，新增以下内容 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件 _config.yml(位于 theme/next 内)，启用搜索功能 123# Local searchlocal_search: enable: true 执行部署命令后，博客就有了搜索功能了。 这里给出 NexT 主题的第三方集成服务网址，上面给出了各个第三方服务的详细安装方法。 初次部署完结结语到此为止，整个博客的基础功能已经具备了，静态博客搭建指北的第一篇就到这里结束了。有些地方写的并不十分详细，原因就是懒→_→ 贴出一篇更为详细的搭建说明留作参考，更多配置相关请查看官方文档。 日后研究出更多 Hexo 功能或插件的使用方法再来继续更新这个系列。 以上！]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写博客啦]]></title>
    <url>%2F2018%2F08%2F31%2F%E5%BC%80%E5%8D%9A%E5%AE%A2%E5%95%A6%2F</url>
    <content type="text"><![CDATA[在不努力就买不起键盘、台灯、书架、MBPR… 所以，努力吧～！]]></content>
      <categories>
        <category>胡说八道</category>
      </categories>
  </entry>
</search>
